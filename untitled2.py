# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hh34YfPeqLQObnOFzHJHcawJCvbip7x9
"""

import pandas as pd

# Configurar pandas para que muestre TODAS las columnas sin truncar en Colab
pd.set_option('display.max_columns', None)    # Ver todas las columnas
pd.set_option('display.max_rows', 100)        # Puedes ajustarlo si quieres m√°s filas
pd.set_option('display.width', 1000)          # Ancho para evitar que se corte
pd.set_option('display.max_colwidth', None)   # Mostrar el contenido completo de cada celda

# Leer el archivo CSV
file_path = "/content/PuntoY.csv"  # Ruta en Colab despu√©s de subir el archivo
df = pd.read_csv(file_path, encoding="latin1")

# Mostrar la tabla completa
display(df)

fecha_cols = df.columns[2:]         # columnas desde la tercera en adelante (fechas)
col_base = fecha_cols[0]            # primera fecha encontrada en esas columnas
print(col_base)

# Detectar columnas de fechas
fecha_cols = df.columns[2:]

# Fecha base
col_base = fecha_cols[0]
fecha_base = datetime.strptime(col_base, "%m/%d/%Y")

# Crear DataFrame con diferencias redondeadas a 3 decimales
df_dif = df[["Abscisa"]].copy()
for col in fecha_cols:
    df_dif[col] = (df[col] - df[col_base]).round(5)

# Calcular meses desde base (por columna)
meses = {}
for col in fecha_cols:
    fecha_actual = datetime.strptime(col, "%m/%d/%Y")
    dias = (fecha_actual - fecha_base).days
    meses[col] = round(dias / 30, 2)

# Crear fila de meses como DataFrame
fila_meses = pd.DataFrame([["Meses desde base"] + list(meses.values())], columns=["Abscisa"] + list(fecha_cols))

# Combinar la fila con la tabla de diferencias
df_final = pd.concat([fila_meses, df_dif], ignore_index=True)

# Mostrar resultado final
display(df_final)

# Detectar columnas de fechas
fecha_cols = df.columns[2:]

# Inicializar DataFrame de tasas
df_tasa = df[["Abscisa"]].copy()
col_labels = ["Abscisa"]
fila_meses = {"Abscisa": "Meses entre fechas"}

# Primera columna: tasa 0 porque no hay anterior
col_labels.append(fecha_cols[0])
df_tasa[fecha_cols[0]] = 0
fila_meses[fecha_cols[0]] = 0.00

# Calcular tasas con respecto a la anterior y renombrar columnas
for i in range(1, len(fecha_cols)):
    col_actual = fecha_cols[i]
    col_anterior = fecha_cols[i - 1]

    # Fechas como datetime
    f_actual = datetime.strptime(col_actual, "%m/%d/%Y")
    f_anterior = datetime.strptime(col_anterior, "%m/%d/%Y")

    # Calcular meses transcurridos
    meses_transcurridos = round((f_actual - f_anterior).days / 30, 2)

    # Etiqueta de comparaci√≥n
    nueva_col = f"{col_actual} - {col_anterior}"
    col_labels.append(nueva_col)

    # Tasa de cambio por mes
    df_tasa[nueva_col] = ((df[col_actual] - df[col_anterior]) / meses_transcurridos).round(3)
    fila_meses[nueva_col] = meses_transcurridos

# Reorganizar columnas y combinar fila de meses
df_tasa = df_tasa[col_labels]
fila_meses_df = pd.DataFrame([fila_meses])
df_final = pd.concat([fila_meses_df, df_tasa], ignore_index=True)

# Mostrar tabla final
display(df_final)

# Eliminar filas sin abscisa
df = df.dropna(subset=["Abscisa"])

# Obtener columnas de fecha
fecha_cols = df.columns[2:]
fechas = [datetime.strptime(f, "%m/%d/%Y") for f in fecha_cols]

# Graficar todas las abscisas (o limita con df.head(n))
plt.figure(figsize=(14, 7))

for _, row in df.iterrows():
    plt.plot(fechas, row[fecha_cols], label=row["Abscisa"])

# Configurar gr√°fico
plt.xlabel("Fecha")
plt.ylabel("Profundidad (Y)")
plt.title("Evoluci√≥n de la profundidad Y por abscisa")
plt.xticks(rotation=45)
plt.grid(True)
plt.legend(title="Abscisa", bbox_to_anchor=(1.05, 1), loc='upper left', ncol=1)
plt.tight_layout()

plt.show()

# Entrada del usuario
columna_a_evaluar = input("Ingrese el nombre de la columna/fecha a evaluar (ej. 1/20/2025): ")
umbral_minimo = float(input("Ingrese el valor m√≠nimo permitido: "))

# Generar columnas
df["Alerta"] = df[columna_a_evaluar].apply(lambda x: "ALERTA" if x < umbral_minimo else "OK")
df["Margen"] = (df[columna_a_evaluar] - umbral_minimo).round(3)

# Mostrar resultado
print(df[["Abscisa", columna_a_evaluar, "Margen", "Alerta"]])

import pandas as pd

# Leer archivo
file_path = "/content/PuntoY.csv"
df = pd.read_csv(file_path, encoding="latin1")
df = df.dropna(subset=["Abscisa"])

# Solicitar columna y umbral
columna_a_evaluar = input("Ingrese el nombre de la columna/fecha a evaluar (ej. 1/20/2025): ")
umbral_minimo = float(input("Ingrese el valor m√≠nimo permitido: "))

# Calcular margen y alerta
df["Margen"] = (df[columna_a_evaluar] - umbral_minimo).round(3)
df["Alerta"] = df["Margen"].apply(lambda x: "üî¥ ALERTA" if x < 0 else "üü¢ OK")

# Subtabla de resultados
df_resultado = df[["Abscisa", columna_a_evaluar, "Margen", "Alerta"]]

# Estilo visual (resalta filas en alerta)
def resaltar_alertas(row):
    return ['background-color: red; color: white' if row["Alerta"] == "üî¥ ALERTA" else '' for _ in row]

# Mostrar como tabla estilizada (solo en Jupyter/Colab)
df_resultado.style.apply(resaltar_alertas, axis=1)

# Ingresar umbral m√≠nimo
umbral_minimo = float(input("Ingrese el valor m√≠nimo permitido: "))

# Detectar columnas de fechas
fecha_cols = df.columns[2:]

# Calcular diferencias
df_diferencias = df[["Abscisa"]].copy()
for col in fecha_cols:
    df_diferencias[col] = (df[col] - umbral_minimo).round(2)

# Convertir a formato para heatmap
df_heat = df_diferencias.set_index("Abscisa")

# Crear heatmap con valores dentro
plt.figure(figsize=(15, 10))
sns.heatmap(
    df_heat,
    cmap="RdYlGn",     # verde a rojo
    center=0,          # punto medio en 0 (umbral)
    annot=True,        # mostrar los valores
    fmt=".2f",         # formato con 2 decimales
    linewidths=0.5,
    cbar_kws={"label": "Margen respecto al umbral"}
)

# Mejoras visuales
plt.title("Mapa de calor con valores: margen de cada punto frente al umbral")
plt.xlabel("Fecha")
plt.ylabel("Abscisa")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Extraer columnas de fecha
fecha_cols = df.columns[2:]

# Calcular los cambios de Y entre fechas consecutivas
cambios = pd.DataFrame()
for i in range(1, len(fecha_cols)):
    fecha_anterior = fecha_cols[i - 1]
    fecha_actual = fecha_cols[i]
    cambio = df[fecha_actual] - df[fecha_anterior]

    mes_actual = datetime.strptime(fecha_actual, "%m/%d/%Y").strftime("%B")
    cambios[f"{mes_actual} ({fecha_anterior} ‚Üí {fecha_actual})"] = cambio

# Convertir a formato largo
df_largo = cambios.melt(var_name="Mes_Periodo", value_name="Cambio")
df_largo["Mes"] = df_largo["Mes_Periodo"].apply(lambda x: x.split(" ")[0])

# Agrupar por mes y obtener promedio
promedio_mensual = df_largo.groupby("Mes")["Cambio"].mean().sort_values()

# Graficar
plt.figure(figsize=(10, 5))
sns.barplot(x=promedio_mensual.index, y=promedio_mensual.values, hue=promedio_mensual.index, palette="coolwarm", legend=False)

plt.axhline(0, color='gray', linestyle='--')
plt.title("¬øEn qu√© mes se erosiona m√°s?")
plt.ylabel("Cambio promedio de profundidad (Y)")
plt.xticks(rotation=45)
plt.grid(True)
plt.tight_layout()
plt.show()

# 2. Definir columnas de fechas
fecha_cols = df.columns[2:]
fechas = [datetime.strptime(f, "%m/%d/%Y") for f in fecha_cols]
dias = np.array([(f - fechas[0]).days for f in fechas]).reshape(-1, 1)

# 3. Definir el umbral cr√≠tico (puedes cambiarlo)
umbral = 0.6

# 4. Lista para almacenar los resultados
resultados = []

# 5. Loop por cada abscisa
for _, row in df.iterrows():
    abscisa = row["Abscisa"]

    try:
        # Convertir valores a num√©rico (por si hay errores de formato)
        y_vals = pd.to_numeric(row[fecha_cols], errors='coerce').values.reshape(-1, 1)

        # Saltar si hay datos faltantes
        if np.isnan(y_vals).any():
            continue

        # 6. Ajustar regresi√≥n lineal
        modelo = LinearRegression()
        modelo.fit(dias, y_vals)

        pendiente = modelo.coef_[0][0]
        intercepto = modelo.intercept_[0]

        # 7. Profundidad actual (√∫ltima fecha)
        valor_actual = y_vals[-1][0]
        bajo_umbral = "S√≠" if valor_actual < umbral else "No"

        # 8. Calcular fecha estimada de cruce (si aplica)
        if pendiente < 0:
            dias_cruce = (umbral - intercepto) / pendiente
            fecha_cruce = fechas[0] + timedelta(days=dias_cruce)
            fecha_str = fecha_cruce.strftime("%Y-%m-%d")
        else:
            fecha_str = "No aplica"

        # 9. Guardar resultados
        resultados.append({
            "Abscisa": abscisa,
            "Pendiente": round(pendiente, 4),
            "Profundidad actual": round(valor_actual, 3),
            f"¬øYa est√° bajo {umbral}m?": bajo_umbral,
            f"Fecha cruce umbral {umbral}m": fecha_str
        })

    except Exception as e:
        print(f"‚ö†Ô∏è Error en abscisa {abscisa}: {e}")
        continue

# 10. Convertir a DataFrame y mostrar
df_resultado = pd.DataFrame(resultados)
print(df_resultado)